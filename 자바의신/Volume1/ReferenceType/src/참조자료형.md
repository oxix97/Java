# 자바의 신

---

### 참조자료형

기본자료형과 참조자료형을 쉽게 구분하려면 String을 제외한 나머지 참조 자료형들은 new 라는 예약어가 반드시 필요하다 <br>
책에서는 자바로 개발하다 보면 세상에는 엄청나게 많은 참조 자료형이 있다는 것을 알게 된다고 말한다. <br>
지금까지 배운 연산자들은 기본 자료형을 위하여 존재하는 것이다. 그 중에서 +는 String 클래스에서만 사용가능하며, 나머지는 사용할 수 없다. <br>
그 이외에 다른 참조 자료형이 사용할 수 있는 연산자는 = 뿐이다.

**Q.** 그렇다고 하면 조건문이나 반복문에서 가능할까? <br>
**A.** 그냥 사용은 불가능하지만 리턴 타입이 boolean 타입인 경우 가능하다.

참조 자료형은 new라는 예약어를 사용한다고 하는데 new 뒤에 나오는 것이 생성자이다. 이제 생성자를 알아보자.

---
### 기본 생성자

자바는 생성자를 만들지 않아도 자동을 만들어 지는 기본 생성자가 있다.<br>
생성자는 메소드와 비슷하게 생겼지만, 리턴 타입이 없고 클래스 이름으로 되어있다.

~~~java
public class ReferenceString {
    public static void main(String[] args) {
        ReferenceString reference = new ReferenceString();
    }
}
~~~
기본 생성자는 이렇게만 해도 생성이 된다.

---
#### 그럼 자바에서는 왜 생성자가 필요할까??

책에서는 다음과 같이 설명한다.
> 자바의 생성자는 자바 클래스의 객체를 생성하기 위해서 존재한다. <br>
> 방금 살펴본 main() 메소드에서 reference 라는 것이 바로 객체다.<br>
> 지금까지 이 책을 보면서 여러분들이 간단하게 만들어 왔던 메소드나 생성자는 선언 방식이 비슷하다 <br>
> 단지 리턴 타입이 없고, 메소드 이름 대신 클래스 이름과 동일하게 이름을 지정하는 것 뿐이다. <br>
> 이름이 동일해야 컴파일러가 생성자 인지 알아 차릴 수 있기 때문이다.

---
#### 그렇다면 생성자는 여러개 만들어도 되는건가? 

기본 생성자가 있으면 다른 생성자도 추가로 만들수 있다는건데 여러개를 만들어도 상관이 없는지 책에서는
> 1개여도 되고 100개여도 상관이 없다고 한다. <br>
> 그 이유는 자바 패턴 중에서 DTO라는 것이 있다. 어떤 속성을 갖는 클래스를 만들고, 그 속성들을 수비게 전달하기 위해 DTO라는 것을 만든다. <br>
> DTO란? Data Transfer Object 의 약자로 데이터를 다른 서버로 전달하기 위한 것이 주 목적이다.<br>
> 한 클래스의 객체를 생성할 때 어떤 이의 정보를 아무 것도 모를 수도 있고, 이름과 전화번호만 알 수 있고 각각의 상황에 따른 생성자를 추가 하기 위해 각 생성자의 역할이 부여되는 것이다.

---
### this

~~~java
public class ReferenceString {
    public String name;
    public ReferenceString(String name){
        this.name = name;
    }
    public static void main(String[] args) {
        ReferenceString reference = new ReferenceString("name");
    }
}
~~~
위의 코드를 보면 name앞에 this라는 예약어를 사용했다. this 예약어는 생성자와 메소드 안에서 사용 가능하며<br>
this.name은 인스턴스 변수로 매개변수 name과 구별하기 위해서 사용한다. 
이러한 혼동을 가장 쉽게 피하는 방법은 매개 변수와 인스턴스 변수의 이름을 다르게 하는 것이다. <br>
하지만, 이름을 다르게 하는 것보다 간단한 방법이 this라는 예약어를 사용하는 것이라 생각한다.

### 메소드 오버로딩

앞서 본 것처럼 생성자는 매개 변수들을 서로 다르게 하여 선언 할 수 있다. 그러면 메소드 역시 이름은 같게 하고 매개 변수들을 다르게 하여 만들수 있다.

예를 들면
~~~java
public class ReferenceString {
    
    public void print(int data) {

    }

    public void print(String data) {

    }

    public void print(int iData, String sData) {

    }

    public void print(String sData, int iData) {

    }

    public static void main(String[] args) {
        ReferenceString reference = new ReferenceString();
        
    }
}
~~~
이렇게 메소드 이름은 모두 동일하지만, 각 메소드의 매개 변수의 종류와 개수, 순서가 다르다.

이와 같이 개수가 같아도 타입의 순서가 다르면 다른 메소드처럼 인식된다. 

**여기서 중요한 점은** 매개 변수의 이름이 아니라 매개 변수의 타입이다. 타입이 다르면 다른 메소드로 인식하지만<BR>
타입이 같고 변수 이름이 같으면 같은 메소드로 인식한다. <br>
실제로 위의 코드들은 실행 하더라도 문제가 발생되지 않는다. 이와 같이 메소드의 이름을 같도록 하고, 매개 변수만을 다르게 하는 것은 오버로딩이라고 한다.

---
#### 오버로딩을 쓰는 이유

