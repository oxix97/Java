# 자바의 신

---
## 연산자

대부분의 연산자는 기본 자료형을 더하거나 빼는 등의 계산을 위해 사용하는데 기본 자료형에 연산자를 사용할 수는 있지만
<br> 참조자료형에서는 기본적인 연산자 사용이 안된다. 하지만 String 이라는 클래스에서만 + 연산이 가능하다.

---
### 산술 연산자

>- **+ :** 더하기 연산자
>- **- :** 빼기 연산자
>- _* :_ 곱하기 연산자
>- **/ :** 나누기 연산자
>- **% :** 나머지 연산자

_+_ 와 _-_ 는 일반 적인 덧셈 뺄셈과 다를 것이 없다.

_*_ 와 _/_ 중에 나누기 역할을 하는 _/_ 가 int 형으로 5 / 4을 했을 때 값이 1이 나오는데 이는 기본 자료형인 int 에서 소수점을 취급하지 않기 때문에 자동으로 버림이 된다.
<br>그렇기 때문에 float 나 double 이라는 실수형 자료형을 사용하면 1.25라는 값이 나오게 된다.

_%_ 같은 경우 나머지값을 구하는데 사용이 된다. 53 / 10 하면 나누기 같은 경우는 int 형으로 5이 나오지만 53 % 10을 하게 되면 나머지인 3이 나오게 된다.

---
### 복합 대입 연산자

>- _+= :_ 기존 값에 우측 항의 값을 더함
>- _-= :_ 기존 값에 우측 항의 값을 뺌
>- _*= :_ 기존 값에 우측 항의 값을 곱함
>- _/= :_ 기존 값을 우측 항의 값으로 나눔
>- _%= :_ 기존 값을 우측 항의 값으로 나눈 나머지

---
### 단항 연산자

>- _+ :_ 변수 * 1을 의미한다.
>- _- :_ 변수 * -1을 의미한다.
>- _++ :_ 해당 변수의 값을 1 증가시킨다.
>- _-- :_ 해당 변수의 값을 1 감소시킨다.
>- _! :_ 논리 부정 연산자로 true->false , false -> true;

_+_ 같은 경우에는 정수가 양수라는 의미를 보여줄 때 쓴다. ->  왜 쓰는지 솔직히 잘 모르겠다. :(

_-_ 같은 경우에는 양수를 음수로, 음수를 양수로 변환하게 만들 수 있다.
~~~java
public void unary(){
        int value = -10;
        System.out.println(+value);
        System.out.println(-value);
}
~~~
결과 
> -10<br>
> 10

_++_ 와 _--_ 같은 경우에는 해당 변수값을 1증가, 1감소하는 역할을 하는데  <br>

++value 인 경우에는 value라는 변수를 참조하기 전에 1을 증가시킨다. --도 마찬가지로 변수를 참조하기 전에 1을 감소시킨다.

value++ 인 경우에는 value라는 변수를 참조한 이후에 1을 증가시키고 -- 역시 마찬가지로 변수를 참조한 이후에 1을 감소시킨다.

~~~java
public void unary(){
        int value = 1;
        System.out.println(value++);
        System.out.println(value);
        System.out.println(++value);
}
~~~

결과
> 1<br>
> 2<br>
> 3

- 첫 번째 value++은 출력문을 출력하고 난 이후에 value를 참조하여 1 증가시킨다.
- 두 번째 value에서는 그냥 값만 출력한다.
- 세 번째 value에서는 value를 참조하여 1 증가시킨 다음 출력문을 실행한다.

---
### 계산 순서

> 1 + 2 * 3 = ?

이 식의 수행 결과는 수학 공식을 그대로 따르기 때문에 답은 7이다.

**하지만** ( 1 + 2 ) * 3 은 괄호 안에 식 먼저 계산하여 답이 9가 된다. 이처럼 수행 결과에 우선순위가 존재한다.
<br> 우선 순위는 다음과 같다.

| 구분 | 연산자 | 우선 순위 |
|: --- :|: ----------- :|: --- :|
| 단항 연산자 | ++ , -- , + , - , ! , ~ | 1 |
| 산술 연산자 | * , / , %  | 2 |
| 산술 연산자 | + , - | 3 |

위의 표에서 다루지 않은 것이 하나 있는데 바로 ~ 이다. <br>
2진수로 되어있는 비트 값이 0 -> 1 , 1 -> 0 으로 바꾸는데 사용한다.

예를 들면
~~~java
public void unary(){
    
        byte a = 127;
        byte b = 1;

        System.out.println(~a);
        System.out.println(~b);   
}
~~~

**실행결과**

>-128<br>
> -2

---
### 비교 연산자

- == : 같음
- != : 같지 않음
- _>_  : 왼쪽 값이 큼
- _>=_ : 왼쪽 값이 같거나 큼
- < : 왼쪽 값이 작음
- <= : 왼쪽 값이 같거나 작음

왼쪽 오른쪽에 각각 비교할 값이 있어야하며, 모든 결과는 반드시 true, false 가 된다.

비교 연산자 중에서도 등가 비교 연산자, 대소 비교 연산자로 나뉘는데 다음과 같다.

#### 등가 비교 연산자 : == , !=

#### 대소 비교 연산자 : > , >= , < ,<=

| 연산자 | 사용 가능한 타입 |
|:----|:-------------|
| == , != | 모든 기본 자료형과 참조 자료형 -> 즉, 모든 타입 |
| < , <= , > , >= | boolean을 제외한 기본 자료형 |

---
### 논리 연산자

- && : AND 결합 
- || : OR 결합

|| 값  | |  결과  |
|:---|:---|:---|:---|
| x | y | x&&y | x ll y |
| T | T | T | T |
| T | F | F | T |
| F | T | F | T |
| F | F | F | F |

---
### 아주 특이한 ?: 연산자

조건문 if문을 간단하게 처리해주는 삼항 연산자이다.

예를 들어

~~~java
public class OperatorClass {
    public static String operator (int point) {
        return point >= 80 ? "Pass" : "Nonpass";
    }
    public static void main(String[] args) {
        System.out.println(operator(85));
        System.out.println(operator(75));
    }
}
~~~
실행 결과

>Pass<br>
> Nonpass
> 
? 앞에 조건을 만족하면 위의 코드에서는 Pass가 반환되며 , 만족하지 못하면 Nonpass가 반환된다.


